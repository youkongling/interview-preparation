# 2020-05-27
webpack都更新到v5了，好久没看了，刷到就看看新出了什么东西  

## Webpack5 上手测评
原文链接 [Webpack5 上手测评](https://juejin.im/post/5ecd05a1f265da76c4243fe6?utm_source=gold_browser_extension)   

```
昨天webpack v5就看到Module Federation这部分就因为要搬砖没看下去，晚上刷了一晚上的手机摄影的教程（真香），等看完这期教程，整体的梳理下生活的信息也可以，今天接着看webpack剩下的部分（每天零零碎碎的学点）
```

# 2020-05-28
## 精读《Webpack5 新特性 - 模块联邦》  
原文链接 [精读《Webpack5 新特性 - 模块联邦》](https://juejin.im/post/5e781330518825492e4980b3)  [Webpack 新功能 Module Federation 深入解析](https://www.shangyexinzhi.com/article/1724057.html)  

Webpack5 模块联邦让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布  

模块联邦的使用方式如下：
```
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
  // other webpack configs...
  plugins: [
    new ModuleFederationPlugin({
      name: "app_one_remote",
      remotes: {
        app_two: "app_two_remote",
        app_three: "app_three_remote"
      },
      exposes: {
        AppContainer: "./src/App"
      },
      shared: ["react", "react-dom", "react-router-dom"]
    }),
    new HtmlWebpackPlugin({
      template: "./public/index.html",
      chunks: ["main"]
    })
  ]
};
```  
模块联邦本身是一个普通的webpack插件ModuleFederationPlugin，插件有几个重要参数：  
1. name ，必须，唯一 ID，作为输出的模块名，使用的时通过 ${name}/${expose} 的方式使用；  
2. library ，必须，其中这里的 name 为作为 umd 的 name；  
3. remotes ，可选，表示作为 Host 时，去消费哪些 Remote；  
4. exposes ，可选，表示作为 Remote 时，export 哪些属性被消费；  
5. shared ，可选，优先用 Host 的依赖，如果 Host 没有，再用自己的；

```
// app_two 的 webpack 配置
export default {
  plugins: [
    new ModuleFederationPlugin({
      name: "app_two",
      library: { type: "var", name: "app_two" },
      filename: "remoteEntry.js",
      exposes: {
        Search: "./src/Search"
      },
      shared: ["react", "react-dom"]
    })
  ]
};
```  
正是因为 Search 在 exposes 被导出，我们因此可以使用 [name]/[exposes_name] 这个模块，这个模块对于被引用应用来说是一个本地模块   


方法一：让每个子应用都分开打包，主应用不管，这样不会有问题，但问题就是尺寸大，而且大了不是一点点。   

方法二：主应用包含 antd 和 react，子应用如果版本一致不打包 react 和 antd，版本不一致就自己打一份，但有几个问题：
1. antd 和 react 是通过 umd 的方式同步载入的，主应用初始化会比较慢  
2. 主应用升级了 antd 的时候，所有子应用可能需要一起升级，这个成本就很大了    

方法三：利用 Module Federation 的 shared 能力，子应用的依赖如果和主应用匹配，那么，能解决方法二里的第一个问题，但第二个问题依旧解不了。 方法四：利用 Module Federation 的 remotes 能力，再提一个应用专门提供库被消费，看起来前面的问题都能解。  

