# 2020-08-15
[冴羽的博客](https://github.com/mqyqingfeng/Blog)

## 节流防抖
[JS中的箭头函数与this](https://juejin.im/post/6844903573428371464) 
```
规则一：箭头函数只能用赋值式写法，不能用声明式写法
规则二：如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号
规则三：如果函数体只有一句话，可以不加花括号
规则四：如果函数体没有括号，可以不写return，箭头函数会帮你return
```
```
this是使用call方法调用函数时传递的第一个参数，它可以在函数调用时修改，在函数没有调用的时候，this的值是无法确定
call方法接收的第一个参数就是this，这里我们传了一个undefined, 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
对象中函数的调用可以手动指定this, obj.greet.call({name: 'Spike'}) 

函数完整的调用方法是使用call方法，包括test.call(context, name)和obj.greet.call(context,name)，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；构造函数稍微特殊一点，它的this直接指向new之后返回的对象；window.setTimeout()和window.setInterval()默认的是this是window对象
```
```
箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的
不能用call方法修改里面的this
多层对象嵌套里箭头函数里this是和最最外层保持一致的
```

[7分钟理解JS的节流、防抖及使用场景](https://juejin.im/post/6844903669389885453) 
[JavaScript专题之跟着underscore学防抖 ](https://github.com/mqyqingfeng/Blog/issues/22)
```
防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

function debounce(func, wait) {
    let timeout;

    return function () {
        const context = this;
        const args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```
[JavaScript专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)
```
节流的原理很简单：如果你持续触发事件，每隔一段时间，只执行一次事件

function throttle(func, wait) {
  let timeout, context

  return function () {
    context = this
    args = arguments

    if (!timeout) {
      timeout = setTimeout(function() {
        timeout = null
        func.apply(context, args)
      }, wait)
    }
  }
}
```
[Lodash 防抖节流函数实现原理](https://juejin.im/post/6844903879017021454)
[手撕源码系列 —— lodash 的 debounce 与 throttle](https://juejin.im/post/6844903990639984654)
```
防抖：将一组例如按下按键这种密集的事件归并成一个单独事件
节流：保证每 X 毫秒恒定地执行一些操作
debounce 将密集触发的事件合并成一个单独事件（不限时间，你可以一直密集地触发，它最终只会触发一次）而 throttle 在 debounce 的基础上增加了时间限制(maxWait)，也就是你一直密集地触发时间，但是到了限定时间，它一定要触发一次，也就是上文中提到的 a constant flow of executions
```

## 事件循环
[面试题：说说事件循环机制(满分答案来了)](https://mp.weixin.qq.com/s/QgfE5Km1xiEkQqADMLmj-Q)
```
1. 先说基本知识点，宏任务、微任务有哪些  
2. 说事件循环机制过程，边说边画图出来  
3. 说async/await执行顺序注意，可以把 chrome 的优化，做法其实是违反了规范的，V8 团队的PR这些自信点说出来，显得你很好学，理解得很详细，很透彻  
4. 把node的事件循环也说一下，重复1、2、3点，node中的第3点要说的是node11前后的事件循环变动点  
```
[js事件循环](https://cloud.tencent.com/developer/article/1332957)
js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行。在执行代码过程中，如果遇到一些异步代码(比如setTimeout,ajax,promise.then以及用户点击等操作),那么浏览器就会将这些代码放到一个线程(在这里我们叫做幕后线程)中去等待，不阻塞主线程的执行，主线程继续执行栈中剩余的代码，当幕后线程（background thread）里的代码准备好了(比如setTimeout时间到了，ajax请求得到响应),该线程就会将它的回调函数放到任务队列中等待执行。而当主线程执行完栈中的所有代码后，它就会检查任务队列是否有任务要执行，如果有任务要执行的话，那么就将该任务放到执行栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。因此，这叫做事件循环  
```
1. 检查Macrotask 队列是否为空,若不为空，则进行下一步，若为空，则跳到3
2. 从Macrotask队列中取队首(在队列时间最长)的任务进去执行栈中执行(仅仅一个)，执行完后进入下一步
3. 检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）
4. 从Microtask队列中取队首(在队列时间最长)的任务进去事件队列执行,执行完后，跳到3

一次事件循环只执行处于 Macrotask 队首的任务，执行完成后，立即执行 Microtask 队列中的所有任务
```
[面试一定会问到的-js事件循环](https://juejin.im/post/6844903968292749319)
```
主线程：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行
工作线程：也称幕后线程，这个线程可能存在于浏览器或js引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件

js 核心还是同步阻塞的 而对于 js 的异步事件，因为有事件循环机制，异步事件就是由事件驱动异步非阻塞的
```

# 2020-08-22
## async & await
[理解 JavaScript 的 async/await](https://segmentfault.com/a/1190000007535316)  
[async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)
[8张图让你一步步看清async/await和promise的执行顺序](https://zhuanlan.zhihu.com/p/52000508) (精彩)
```
1. async/await的优势在于处理then链, Promise 方案的死穴——参数传递太麻烦了，看着就晕！
2. 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果
3. 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。
```