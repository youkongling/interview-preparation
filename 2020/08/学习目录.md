# 2020-08-15
[冴羽的博客](https://github.com/mqyqingfeng/Blog)

## 节流防抖
[JS中的箭头函数与this](https://juejin.im/post/6844903573428371464) 
```
规则一：箭头函数只能用赋值式写法，不能用声明式写法
规则二：如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号
规则三：如果函数体只有一句话，可以不加花括号
规则四：如果函数体没有括号，可以不写return，箭头函数会帮你return
```
```
this是使用call方法调用函数时传递的第一个参数，它可以在函数调用时修改，在函数没有调用的时候，this的值是无法确定
call方法接收的第一个参数就是this，这里我们传了一个undefined, 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）
对象中函数的调用可以手动指定this, obj.greet.call({name: 'Spike'}) 

函数完整的调用方法是使用call方法，包括test.call(context, name)和obj.greet.call(context,name)，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；构造函数稍微特殊一点，它的this直接指向new之后返回的对象；window.setTimeout()和window.setInterval()默认的是this是window对象
```
```
箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的
不能用call方法修改里面的this
多层对象嵌套里箭头函数里this是和最最外层保持一致的
```

[7分钟理解JS的节流、防抖及使用场景](https://juejin.im/post/6844903669389885453) 
[JavaScript专题之跟着underscore学防抖 ](https://github.com/mqyqingfeng/Blog/issues/22)
```
防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

function debounce(func, wait) {
    let timeout;

    return function () {
        const context = this;
        const args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```
[JavaScript专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)
```
节流的原理很简单：如果你持续触发事件，每隔一段时间，只执行一次事件

function throttle(func, wait) {
  let timeout, context

  return function () {
    context = this
    args = arguments

    if (!timeout) {
      timeout = setTimeout(function() {
        timeout = null
        func.apply(context, args)
      }, wait)
    }
  }
}
```
[Lodash 防抖节流函数实现原理](https://juejin.im/post/6844903879017021454)
[手撕源码系列 —— lodash 的 debounce 与 throttle](https://juejin.im/post/6844903990639984654)
```
防抖：将一组例如按下按键这种密集的事件归并成一个单独事件
节流：保证每 X 毫秒恒定地执行一些操作
debounce 将密集触发的事件合并成一个单独事件（不限时间，你可以一直密集地触发，它最终只会触发一次）而 throttle 在 debounce 的基础上增加了时间限制(maxWait)，也就是你一直密集地触发时间，但是到了限定时间，它一定要触发一次，也就是上文中提到的 a constant flow of executions
```

## 事件循环