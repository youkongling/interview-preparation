# 支付宝前端面试 2017-02-27  
头条失利面试后，特地来一趟杭州，26号上午去了滴滴，面试感觉还不错，让我等消息，希望感觉还是挺大的，下午去了支付宝面试，面试官人挺好的，整场面试下来，没啥太大压力，主要是自己的技术深度不够，应该是没过，不过还是有收获，写点东西记录一下  

## 笔试部分  
1. 说说对洗牌算法的理解和如何验证其正确性  
    洗牌算法之前没了解过，刚面到的时候好蒙，闲话不多说，这里说下洗牌算法的js实现  

    Fisher-Yates  
    这是最经典的洗牌算法，其算法思想是从原数组中随机抽取一个新的元素到新数组中  
    
    从还没处理的数组（假如还剩n个）中，产生一个[0,n]之间的随机数random

    从剩下的n个元素中把第random个元素取出到新数组中  
    
    删除原数组第random个元素  

    重复第2 3步直到所有的元素取完 

    最终返回一个新的打乱的数组  

    代码实现  
    ```  
    function shufle(arr){
        var result = [],
            random;
        while(arr.length > 0){
            random = Math.floor(Math.random() * arr.length);
            result.push(arr[random])
            arr.splice(random, 1)
        }
        return result;
    }
    ```  
    这种算法的时间复杂度是O(n2)  

参考链接 [洗牌算法的js实现](https://github.com/ccforward/cc/issues/44)  
参考链接 [Fisher–Yates shuffle 洗牌算法](https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/)  

2. 还有一道是求解一颗树的最大权重的路径，对算法真的是功底比较薄弱，没耽搁时间，直接说不会  

## 面试部分  
面试官人很好，问的也很全面，没过完全是自己的问题，自己的技术积累还不到家，这里就暂时不为每个题目解答了，先把记得的题目写一下  
1. 说一说你对highChart和EChart的理解，以及两者的区别，除了这两个还用过别的插件吗，分别说下他们的不同？  

2. 说一下你对事件委托和事件代理的理解？  
    什么是事件委托？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，当我们需要对很多元素添加事件的时候，可以通过事件添加到他们的父节点二将时间委托给父节点来触发处理函数  

    为什么要使用事件委托？   
    一般来说，dom需要有事件处理程序，我们都会直接给它设置事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们这里有100个li，每个li都有相同的click事件，那么我们会用for循环的方法来遍历所有的li，然后给他们添加事件，那么这样会存在什么问题呢？  
    在JavaScript中，添加到页面上的事件处理程序的数量将直接关联到页面整体的运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数就越多，就会延长整个页面交互就绪时间，这就是为什么性能优化的主要思想是减少dom操作的原因，如果使用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能  
    每个函数都是一个对象，是对象就会占用内存，内存占用率就越大，自然性能就差了，比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，如果使用事件委托，那么我们就可以只对它的父级这一个对象（如果只有一个父级）进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好  

    事件委托的原理？  
    事件委托是利用事件的冒泡机制来实现的，何为事件冒泡呢？这里介绍下浏览器dom事件处理的过程，dom2.0模型将事件流程分为三个阶段：事件捕获阶段，事件目标阶段，事件冒泡阶段。  
    事件捕获：当某个元素触发某个事件，顶层对象document就会发出一个事件流，随着dom树的节点向目标元素节点流去，直到到达事件真正发生的目标元素，在这个过程中，事件相应的监听函数是不会被触发的  
    事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数，如果没有绑定监听函数，那就不执行  
    事件冒泡：从目标元素开始，往顶层元素传播，途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发，如果想阻止事件冒泡，可以使用event.stopPropgation()或者event.cancelBubble=true来阻止事件的冒泡传播  

    事件委托怎么实现：  
    Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称为事件源，也就是说，target就可以表示为当前事件操作的dom，但是不是真正操作的dom，当然，这个是有兼容性的，标准浏览器用event.target，IE浏览器用event.srcElement，此时知识获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，一般转化为小写再进行比较  
    如果你想将事件委托给父元素来处理，但每个子元素的事件内容又不相同时，这里我们可以给每个子元素添加一个唯一的key来作标识，然后在父元素中对其进行分别的处理
    ```
    const list = document.querySelector('#list)  
    const lists = list.querySelector('#list > li')
    for(let i=0; i<lists.length; i++){
        lists[i].dataset.key = 'list-' + i
    }
    list.addEventListener('click',function(e){
        const event = e || window.event
        const target = event.target || event.srcElement  
        if(target.nodeName.toLocaleLowerCase() === 'li'){
            switch(target.dataset.key){
                case 'list-1':
                    do something-1
                    break
                case 'list-2':
                    do something-2
                    break
                ...
                default:
                    do something-3
                    break
            }
        }
    })  
    ```  
参考链接 [JavaScrip事件代理和委托](https://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html)  
参考链接 [JS的事件委托和事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)  

3. 说一下你对css重绘和重排的理解，两个有什么不同？  
    这一题考的其实是网页性能的问题，我们先理解下对网页性能产生影响到因素，了解下网页是怎么生成的  

    网页生成的过程，大致可以分为五步：  
    - html代码转化为dom 
    - css代码转化为cssom  
    - 结合dom和cssom，生成一棵渲染树（包含每个节点的视觉信息）  
    - 生成布局layout，即将所有的渲染树的节点进行平面合成  
    - 将布局绘制paint在屏幕上  
    
    在这五步里面，第一步和第三步都非常快耗时的是第四步和第五步  
    其中生成布局flow和绘制paint这两步，合称为渲染render  

    重绘和重排  
    网页生成的时候，至少会渲染一次，用户访问的过程中，还会不断的重新渲染  
    以下三种情况，会导致网页重新渲染  
    - 修改dom  
    - 修改样式表  
    - 用户事件  

    重新渲染，就需要重新生成布局和重新绘制，前者叫做重排reflow，后者交货重绘repaint  
    需要注意的是，重绘不一定需要重排，比如改变某个网页元素的颜色，就只会触发重绘，不会触发重排，因为布局没有改变，但是，重排一定会导致重绘，比如改变一个网页元素的位置，就会同时触发重排和重绘，因为布局改变了  

    对于性能的影响  
    重绘和重排会不断触发，这是不可避免的，但是，他们是非常耗费资源的，是导致网页性能低下根本原因  
    要提高网页性能，就是要降低重排和重绘的频率和成本，尽量少触发重新渲染  
    - 一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染  
        - offsetTop/offsetLeft/offsetWidth/offsetHeight  
        - scrollTop/scrollLeft/scrollWidth/scrollHeight  
        - clientTop/clientLeft/clientWidth/clientHeight
        - getComputeStyle()  
    - 所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里，一般的规则是  
        - 样式表越简单，重绘和重排就越快  
        - 重排和重绘的dom层级越高，成本就越高  
        - table元素的重绘和重排成本，要高于div元素  


    提高性能的九个技巧  
    - dom的多个读操作（或者多个写操作），应该放在一起，不要两个读操作之间，加入一个写操作  
    - 如果某个样式是通过重排得到的，那么最好缓存结果，避免下一次用到的时候，浏览器又要重排  
    - 不要一条条的改变样式，而是要通过改变class，或者csstext属性，一次性的改变样式  
    - 尽量使用离线dom，而不是真正的网页dom，来改变元素样式，比如，使用cloneNode()方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点  
    - 先将原素设为display：none(需要一次重排和重绘)，然后对这个节点进行100次操作，最后再恢复显示(需要一次重排和重绘)，这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染  
    - position属性为absolute或fixed的元素，重排的开销会比较小，因为用考虑他对其他元素的影响  
    - 只有必要的时候，才会将元素的display属性设为课件，因为不可见的元素不影响重排和重绘，另外visibility：hidden的元素只会对重绘有影响，不会影响重排  
    - 使用虚拟dom的脚本库，如react  
    - 使用window.requestAnimationFrame()，window.requestIdleCallback()这两个方法调节重新渲染  

参考链接 [网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)  


4. 说一下你对进程和线程的理解？node的多线程怎么处理？  

5. 说一下你对node中Buffer和stream的理解，两者有什么不同，怎么处理？  

6. 说一下jQuery中ready的实现